from Crypto.Util.number import *
from gmpy2 import *

"""
m1: 59492232069971714501687311229192733706923130224717554875806663191584083318146
N1: 80188042996024275537705942748753160783160779482415174987929621275886322305993

m2: 21844799603743325754642272153408582066631106938402190927499402871589610163515
N2: 40650631686060095425268402121699623276655732342325464186856543849690414131589

m3: 7231509440080168998032555957665007522628482094821170372772356091759635302773
N3: 61112785727155145229043270722819518342283933930808205279571741242171630031719
"""

e = 3

c1 = 59492232069971714501687311229192733706923130224717554875806663191584083318146
n1 = 80188042996024275537705942748753160783160779482415174987929621275886322305993

c2 = 21844799603743325754642272153408582066631106938402190927499402871589610163515
n2 = 40650631686060095425268402121699623276655732342325464186856543849690414131589

c3 = 7231509440080168998032555957665007522628482094821170372772356091759635302773
n3 = 61112785727155145229043270722819518342283933930808205279571741242171630031719

from gmpy2 import invert


def mul(lst):
    ret = 1
    for n in lst:
        ret *= n
    return ret

def crt(C, N):
    assert len(C) == len(N)

    total = 0
    modulo = mul(N)

    for n_i, c_i in zip(N, C):
        p = modulo // n_i
        total += c_i * invert(p, n_i) * p
    return total % modulo

def third_root(n):
    m, valid = iroot(n, e)
    if valid:
        print("Cleartext :", long_to_bytes(m))
    else:
        print("Unable to find the third root of :", n)

C = [c1, c2, c3]
N = [n1, n2, n3]

for c in C:
    third_root(c)

x = crt(C, N)
third_root(x)
